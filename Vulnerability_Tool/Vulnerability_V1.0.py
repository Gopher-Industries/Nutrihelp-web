# Importing modules to assist with vulnerability scanning and detecting
import os
import re

# Define text Colour
class Colour:
    GREEN = '\033[92m'
    RED = '\033[91m'
    BLUE = '\033[94m'
    YELLOW = '\033[93m'
    V_PATTEN_NAME = '\033[38;5;208m' # Orange names
    NORMAL = '\033[0m'

# Define Vulnerability Pattern
V_Patterns = {
    "Sql_Injection": re.compile(r'\.query\s*\(.*\+.*\)'),
    "XSS": re.compile(r'res\.send\s*\(.*\+.*\)'),
    "Command_Injection": re.compile(r'exec\s*\(.*\+.*\)'),
    "insecure_file_handling": re.compile(r'fs\.unlink\s*\(.*\)'),
    "insecure_file_upload": re.compile(r'multer\s*\(\s*{.*dest.*}\s*\)')
}
# Opening the files for processing
def AnalyseFile(FileLocation):
    vulnerabilities = {key: [] for key in V_Patterns.keys()}    
    try:
        with open(FileLocation, 'r', encoding='utf-8') as file:
            Data = file.read()
    except Exception as e:
        print(f"Error reading file {FileLocation}: {e}")
        return None

# Check for vulnerabilities based on pre set V_Patterns
    for key, pattern in V_Patterns.items():
        matches = pattern.findall(Data)
        if matches:
            vulnerabilities[key].extend(matches)
    
    return vulnerabilities

# Formatting files for list
def list_files():
    return [f for f in os.listdir('.') if os.path.isfile(f) and f.endswith('.js')]

def OrderedF(Dataset):
    print("|--------------------------------|\n| JavaScript files for Analysis: |\n|--------------------------------|")
    for i, file in enumerate(Dataset, 1):
        print(f"{i} - {file}")

# Result box for outcome of vulnerability scan
def PrintOutcome(Data):
    Outside = max(len(line) for line in Data.splitlines()) + 4
    print('|' + '-' * (Outside - 2) + '|')
    for line in Data.splitlines():
        print(f"| {line.ljust(Outside - 4)} |")
    print('|' + '-' * (Outside - 2) + '|')

# Catches not JavaScript files in directory
def main():
    Dataset = list_files()
    if not Dataset:
        print("No .js files found")
        return
        
# Terminate program when "end" is entered in
    while True:
        OrderedF(Dataset)   
        User_Input = input("\nPlease enter a file number from the listed options\nor\nType 'end' to quit the application \n> ")
        if User_Input == 'end':
            break

# Catches an input ouside of the file number range
        try:
            file_index = int(User_Input) - 1
            if file_index < 0 or file_index >= len(Dataset):
                print(f"\n{Colour.BLUE}|---------------|\n| Invalid input |\n|---------------|{Colour.NORMAL}\nPlease enter the file number from the listed options")
                continue
            
            JsFile = Dataset[file_index]
            print(f"{Colour.YELLOW}\nAnalysing: {Colour.NORMAL}{JsFile}")
            vulnerabilities = AnalyseFile(JsFile)

# This should not get called. However, is left here to future proof the application            
            if not vulnerabilities:
                Outcome = f"Could not read file: {JsFile}"

# No vulnerabilities have been located
            elif not any(vulnerabilities.values()):
                Outcome = f"{Colour.GREEN}No vulnerabilities found.{Colour.NORMAL}"

# Lists the potentiaal vulnerability found
            else:
                Outcome = f"{Colour.RED}Potential Vulnerability Found:  {Colour.NORMAL}\n"
                for key, found in vulnerabilities.items():
                    if found:
                        Outcome += f"{Colour.V_PATTEN_NAME} {key.replace('_', ' ').title()} vulnerabilities:{Colour.NORMAL}\n"
                        for q in found:
                            Outcome += f"    - {q}\n"

# Print Result
            PrintOutcome(Outcome)
# Triggers invalid input - chance to try again
        except ValueError:
            print(f"\n{Colour.BLUE}|---------------|\n| Invalid input |\n|---------------|{Colour.NORMAL}\nPlease Input a number.")

if __name__ == "__main__":
    main()
